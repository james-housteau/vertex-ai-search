#!/usr/bin/env python3
"""
Genesis Version Management Utilities for vertex-ai-search

Provides version management for this Genesis-powered project.
Auto-generated by Genesis - Safe to customize for your project needs.

Usage:
    python .genesis/scripts/version.py --help
    python .genesis/scripts/version.py show
    python .genesis/scripts/version.py bump patch
    python .genesis/scripts/version.py sync
"""

import argparse
import json
import re
import sys
from pathlib import Path
from typing import Dict, Optional

import tomllib


def get_project_version(project_path: Optional[Path] = None) -> str:
    """
    Get version from project's pyproject.toml, package.json, or other version files.

    Args:
        project_path: Path to project directory (defaults to current directory)

    Returns:
        Version string from project files

    Raises:
        FileNotFoundError: If no version files found
        ValueError: If version format is invalid
    """
    if project_path is None:
        project_path = Path.cwd()

    # Try pyproject.toml first (Python projects)
    pyproject_path = project_path / "pyproject.toml"
    if pyproject_path.exists():
        with open(pyproject_path, "rb") as f:
            data = tomllib.load(f)

        # Try different version locations
        version_paths = [["tool", "poetry", "version"], ["project", "version"]]

        for path in version_paths:
            try:
                current = data
                for key in path:
                    current = current[key]
                return current
            except KeyError:
                continue

    # Try package.json (Node.js/TypeScript projects)
    package_json = project_path / "package.json"
    if package_json.exists():
        with open(package_json) as f:
            data = json.load(f)
            if "version" in data:
                return data["version"]

    # Try __init__.py files (Python packages)
    for init_file in project_path.rglob("__init__.py"):
        try:
            relative_path = init_file.relative_to(project_path)
            path_parts = relative_path.parts

            # Skip virtual environments and external packages
            skip_dirs = {
                ".venv",
                "venv",
                "env",
                ".env",
                "node_modules",
                "site-packages",
                ".git",
            }
            if any(part in skip_dirs for part in path_parts):
                continue

            content = init_file.read_text()
            version_match = re.search(r'__version__\s*=\s*["\']([^"\']+)["\']', content)
            if version_match:
                return version_match.group(1)
        except Exception:
            continue

    raise FileNotFoundError(f"No version file found in {project_path}")


def sync_version_to_files(project_path: Path, version: str) -> Dict[str, bool]:
    """
    Synchronize version to common project files.

    Args:
        project_path: Path to project directory
        version: Version string to sync

    Returns:
        Dictionary mapping file paths to success status
    """
    results = {}

    # package.json (Node.js projects)
    package_json = project_path / "package.json"
    if package_json.exists():
        try:
            with open(package_json) as f:
                data = json.load(f)
            data["version"] = version
            with open(package_json, "w") as f:
                json.dump(data, f, indent=2)
            results[str(package_json)] = True
            print(f"✅ Updated {package_json}")
        except Exception as e:
            results[str(package_json)] = False
            print(f"❌ Failed to update {package_json}: {e}")

    # __init__.py files (exclude virtual environments and external packages)
    for init_file in project_path.rglob("__init__.py"):
        try:
            relative_path = init_file.relative_to(project_path)
            path_parts = relative_path.parts

            # Skip common virtual environment and package directories
            skip_dirs = {
                ".venv",
                "venv",
                "env",
                ".env",
                "node_modules",
                "site-packages",
                ".git",
            }
            if any(part in skip_dirs for part in path_parts):
                continue

            content = init_file.read_text()
            if "__version__" in content:
                # Replace __version__ = "..." with new version
                new_content = re.sub(
                    r'__version__\s*=\s*["\'][^"\']*["\']',
                    f'__version__ = "{version}"',
                    content,
                )
                if new_content != content:
                    init_file.write_text(new_content)
                    results[str(init_file)] = True
                    print(f"✅ Updated {init_file}")
        except Exception as e:
            results[str(init_file)] = False
            print(f"❌ Failed to update {init_file}: {e}")

    return results


def bump_version(current_version: str, bump_type: str) -> str:
    """
    Bump version according to semantic versioning.

    Args:
        current_version: Current version string
        bump_type: Type of bump (major, minor, patch, alpha, beta, rc)

    Returns:
        New version string

    Raises:
        ValueError: If version format is invalid or bump type unknown
    """
    # Parse current version
    version_match = re.match(r"(\d+)\.(\d+)\.(\d+)(?:-(.+))?", current_version)
    if not version_match:
        raise ValueError(f"Invalid version format: {current_version}")

    major, minor, patch, prerelease = version_match.groups()
    major, minor, patch = int(major), int(minor), int(patch)

    if bump_type == "major":
        return f"{major + 1}.0.0"
    elif bump_type == "minor":
        return f"{major}.{minor + 1}.0"
    elif bump_type == "patch":
        if prerelease:
            # Remove prerelease for patch bump
            return f"{major}.{minor}.{patch}"
        else:
            return f"{major}.{minor}.{patch + 1}"
    elif bump_type == "alpha":
        if prerelease and "alpha" in prerelease:
            # Increment alpha version
            alpha_match = re.search(r"alpha\.?(\d+)?", prerelease)
            if alpha_match and alpha_match.group(1):
                alpha_num = int(alpha_match.group(1)) + 1
            else:
                alpha_num = 2
            return f"{major}.{minor}.{patch}-alpha.{alpha_num}"
        else:
            return f"{major}.{minor}.{patch}-alpha"
    elif bump_type == "beta":
        return f"{major}.{minor}.{patch}-beta"
    elif bump_type == "rc":
        return f"{major}.{minor}.{patch}-rc"
    else:
        raise ValueError(f"Unknown bump type: {bump_type}")


def update_pyproject_version(project_path: Path, version: str) -> bool:
    """Update version in pyproject.toml file."""
    pyproject_path = project_path / "pyproject.toml"
    if not pyproject_path.exists():
        return False

    try:
        # Read current content
        content = pyproject_path.read_text()

        # Update version in [tool.poetry] section
        new_content = re.sub(
            r'(version\s*=\s*)["\'][^"\']*["\']', f'\\1"{version}"', content
        )

        # Also update [project] version if it exists
        new_content = re.sub(
            r'(\[project\][\s\S]*?version\s*=\s*)["\'][^"\']*["\']',
            f'\\1"{version}"',
            new_content,
        )

        if new_content != content:
            pyproject_path.write_text(new_content)
            print(f"✅ Updated {pyproject_path}")
            return True
        else:
            print(f"ℹ️  No version found to update in {pyproject_path}")
            return True
    except Exception as e:
        print(f"❌ Failed to update {pyproject_path}: {e}")
        return False


def update_package_json_version(project_path: Path, version: str) -> bool:
    """Update version in package.json file."""
    package_json = project_path / "package.json"
    if not package_json.exists():
        return True  # Not an error if file doesn't exist

    try:
        with open(package_json) as f:
            data = json.load(f)

        if "version" in data:
            data["version"] = version
            with open(package_json, "w") as f:
                json.dump(data, f, indent=2)
            print(f"✅ Updated {package_json}")
        return True
    except Exception as e:
        print(f"❌ Failed to update {package_json}: {e}")
        return False


def main():
    """Main CLI entry point."""
    parser = argparse.ArgumentParser(
        description="vertex-ai-search Version Management (Genesis)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    python .genesis/scripts/version.py show
    python .genesis/scripts/version.py bump patch
    python .genesis/scripts/version.py bump minor --sync
    python .genesis/scripts/version.py sync
        """,
    )

    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Show command
    show_parser = subparsers.add_parser("show", help="Show current version")
    show_parser.add_argument(
        "--project", type=Path, help="Project path (default: current directory)"
    )

    # Bump command
    bump_parser = subparsers.add_parser("bump", help="Bump version")
    bump_parser.add_argument(
        "type",
        choices=["major", "minor", "patch", "alpha", "beta", "rc"],
        help="Version bump type",
    )
    bump_parser.add_argument(
        "--project", type=Path, help="Project path (default: current directory)"
    )
    bump_parser.add_argument(
        "--sync", action="store_true", help="Sync version to other files"
    )
    bump_parser.add_argument(
        "--dry-run", action="store_true", help="Show what would be done"
    )

    # Sync command
    sync_parser = subparsers.add_parser(
        "sync", help="Sync version across project files"
    )
    sync_parser.add_argument(
        "--project", type=Path, help="Project path (default: current directory)"
    )
    sync_parser.add_argument(
        "--version", help="Specific version to sync (default: detect current)"
    )

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    project_path = args.project or Path.cwd()

    try:
        if args.command == "show":
            version = get_project_version(project_path)
            print(f"Current version: {version}")

        elif args.command == "bump":
            current_version = get_project_version(project_path)
            new_version = bump_version(current_version, args.type)

            if args.dry_run:
                print(f"Would bump: {current_version} → {new_version}")
                return

            print(f"Bumping: {current_version} → {new_version}")

            # Update primary version files
            success = True
            success &= update_pyproject_version(project_path, new_version)
            success &= update_package_json_version(project_path, new_version)

            if args.sync and success:
                print("Syncing version to other files...")
                sync_version_to_files(project_path, new_version)

            if success:
                print(f"✅ Version bumped to {new_version}")
            else:
                print("❌ Some updates failed")
                sys.exit(1)

        elif args.command == "sync":
            if args.version:
                version = args.version
            else:
                version = get_project_version(project_path)

            print(f"Syncing version {version} across project files...")
            results = sync_version_to_files(project_path, version)

            if results:
                successes = sum(results.values())
                total = len(results)
                print(f"✅ Synced {successes}/{total} files")
            else:
                print("ℹ️  No files to sync")

    except Exception as e:
        print(f"❌ Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
